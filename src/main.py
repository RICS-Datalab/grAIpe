from fastapi import FastAPI, Header, UploadFile, Body, File, Form
from typing import Annotated, Optional, List
from fastapi.responses import FileResponse
from rasterio.enums import Resampling
from pydantic import BaseModel
import orthophoto as ortho
import segmentation as seg
from enum import Enum 
import requests
import rasterio
import uvicorn
import shutil
import os


app = FastAPI()

class User(BaseModel):
        username: str
        password: str

class Authenticator(BaseModel):
        token: str

class Project(BaseModel):
        project_id: int
        task_id: str

class FileName(str, Enum):
    all = "all.zip"
    orthophoto_tif = "orthophoto.tif"
    orthophoto_png = "orthophoto.png"
    orthophoto_mbtiles = "orthophoto.mbtiles"
    textured_model = "textured_model.zip"
    georeferenced_model_las = "georeferenced_model.las"
    georeferenced_model_ply = "georeferenced_model.ply"
    georeferenced_model_csv = "georeferenced_model.csv"    

class IndexName(str, Enum):
     ndvi = "NDVI" 
     ndyi = "NDYI" 
     ndre = "NDRE" 
     ndwi = "NDWI" 
     endvi = "ENDVI" 
     vndvi = "vNDVI" 
     vari ="VARI" 
     exg = "EXG" 
     tgi = "TGI" 
     bai = "BAI" 
     gli = "GLI"
     gndvi = "GNDVI" 
     grvi = "GRVI"
     savi = "SAVI"
     mnli = "MNLI"
     ms = "MS"
     rdvi = "RDVI"
     tdvi = "TDVI" 
     osavi = "OSAVI"
     lai = "LAI"
     evi = "EVI"
     arvi = "ARVI"

class MapName(str, Enum):
     dsm = "DSM"
     dtm = "DTM"

class Data(BaseModel):
    color_map: str = Body('spectral')
    formula: str = Body('NDVI')
    bands: str = Body('RGBNRe')
    hillshade: str = Body('')
    rescale: str = Body('-1%2C1')
    size: str = Body('512')
    format: str = Body('gtiff')
    epsg: str = Body('32629')

class Options(BaseModel):
    name : str 
    value : str 

class OptionsList(BaseModel):
    options : list[Options]
    

@app.post("/login")
async def auth(user: User):
    """
    Authenticate user credentials by sending a POST request to an external authentication API. The API endpoint expects a 
    JSON payload containing the `username` and `password` of the user. If the authentication is successful, the API responds 
    with a JSON payload containing a `token`. The `token` is returned to the caller.

    Args:
        user (User): An instance of the `User` model containing the `username` and `password` of the user.

    Returns:
        str: A token generated by the external authentication API. This token can be used to authenticate 
             subsequent requests to protected API endpoints.

    Raises:
        None
    """
    res = requests.post('http://localhost:8000/api/token-auth/',
                        data={'username': user.username,
                              'password': user.password}).json()
    token = res['token']
    return token

@app.post("/create_project/{name}")
async def create_proj(name, Authorization: Annotated[str | None, Header()] = None):
    """
    Creates a new project by making a POST request to an external API.

    Args:
        name: (str) The name of the project to be created.
        Authorization: (str) token for authorization.

    Returns:
        int: The ID of the newly created project.
    """
    proj_res = requests.post('http://localhost:8000/api/projects/',
                        headers={'Authorization': 'JWT {}'.format(Authorization)},
                        data={'name': name}).json()

    project_id = proj_res['id']
    return project_id

@app.get("/list_projects")
async def list_projs(Authorization: Annotated[str | None, Header()] = None):
    """
    Fetches a list of projects from a remote API endpoint.
    
    Args:
        Authorization: (str) token for authorization.
        
    Returns:
        dict: The list of projects fetched from the API.
    """
    res = requests.get('http://localhost:8000/api/projects/', headers={'Authorization': 'JWT {}'.format(Authorization)})
    return res.json()

@app.post("/create_execute_task/{project}")
async def ask(project, data: str = Form(None), files: List[UploadFile] = File(...), Authorization: Annotated[str | None, Header()] = None):
    """
    Creates a task in the specified project and executes it with the given options and uploaded files.

    :param project: (str) The name of the project to create the task in.
    :param data: (str) Optional data string containing additional task options.
    :param files: (List[UploadFile]) A list of uploaded files to be used as input for the task.
    :param Authorization: (str) Optional JWT authorization token to authenticate the user making the request.
    :return: (dict) A dictionary containing information about the created task.
    """

    options = ortho.optionsListCreation(data)
    print(options)
    
    directory = "uploads"
    if not os.path.exists(directory):
        os.mkdir(directory)
    for file in files:
        with open(os.path.join(directory, file.filename), "wb") as f:
            shutil.copyfileobj(file.file, f)
    
    file_list = []

    for filename in os.listdir('uploads/'):
        if os.path.isfile(os.path.join('uploads/', filename)):
            file_list.append('uploads/'+ filename)

    images = []
    for item in file_list:
        with open(item, 'rb') as f:
            images.append(('images', (item, f.read(), 'image/tif')))

    res = requests.post('http://localhost:8000/api/projects/{}/tasks/'.format(project),
                headers={'Authorization': 'JWT {}'.format(Authorization)},
                files=images,
                data={
                    'options': options
                }).json()
    shutil.rmtree('uploads')
    return res

@app.get("/download/{project}/{task}/{file}")
async def get_orthophoto(project, task, file : FileName, Authorization: Annotated[str | None, Header()] = None):
    """
    Downloads an orthophoto file for the specified project, task, and file name, and saves it locally.

    :param project: (str) The name of the project containing the task and file.
    :param task: (str) The name of the task containing the file.
    :param file: (FileName) The name of the orthophoto file to download.
    :param Authorization: (str) Optional JWT authorization token to authenticate the user making the request.
    :return: (FileResponse) A response object containing the downloaded file.
    """

    res = ortho.Orthophoto(project, task, file, Authorization)
    
    with open(file, 'wb') as f:
        for chunk in res.iter_content(chunk_size=1024):
            if chunk:
                f.write(chunk)

    return FileResponse("{}".format(file), filename=file)

@app.post("/index/{project}/{task}/{index}")
async def get_index(project, task, index : IndexName, data: Optional[Data], Authorization: Annotated[str | None, Header()] = None):
    """
    Endpoint that creates an index from the orthophoto of a given task and project.

    :param project: (str) the name of the project.
    :param task: (str) the name of the task.
    :param index: (IndexName) the index to be calculated, must be one of the available indexes.
    :param data: (Optional[Data]) additional data required to calculate some indexes.
    :param Authorization: (Annotated[str | None, Header()]) optional authorization header.

    :return: (FileResponse) a file response with the calculated index file.
    """

    indexdict = {
        'NDVI' :"orthophoto-NDVI.tif",
        'NDYI' : "orthophoto-NDYI.tif", 
        'NDRE' : "orthophoto-NDRE.tif", 
        'NDWI' : "orthophoto-NDWI.tif", 
        'VNDVI' : "orthophoto-vNDVI.tif", 
        'ENDVI' : "orthophoto-ENDVI.tif", 
        'VARI' :"orthophoto-VARI.tif", 
        'EXG' : "orthophoto-EXG.tif", 
        'TGI' : "orthophoto-TGI.tif", 
        'BAI' : "orthophoto-BAI.tif", 
        'GLI' : "orthophoto-GLI.tif",
        'GNDVI' : "orthophoto-GNDVI.tif", 
        'GRVI' : "orthophoto-GRVI.tif",
        'SAVI' : "orthophoto-SAVI.tif",
        'MNLI' : "orthophoto-MNLI.tif",
        'MS' : "orthophoto-MS.tif",
        'RDVI' : "orthophoto-RDVI.tif",
        'TDVI' : "orthophoto-TDVI.tif", 
        'OSAVI' : "orthophoto-OSAVI.tif",
        'LAI' : "orthophoto-LAI.tif",
        'EVI' : "orthophoto-EVI.tif",
        'ARVI' : "orthophoto-ARVI.tif",
    }

    index_file = indexdict[index]

    content = ortho.Index_creation(project, task, index, data, Authorization)
    with open(index_file, 'wb') as f:
        f.write(content)

    return FileResponse("{}".format(index_file), filename=index_file)

@app.get("/dsm_dtm_chm/{project}/{task}/{file}")
async def get_dtm_dsm_chm(project, task, file : MapName, Authorization: Annotated[str | None, Header()] = None):
    """
    Returns a digital surface model (DSM), a digital terrain model (DTM), or a canopy height model (CHM)
    :param project: (str) the name of the project
    :param task: (str) the name of the task
    :param file: (str) the name of the map (DSM, DTM, or CHM) to retrieve
    :param Authorization: (str, optional) authorization header for authenticated requests
    :return: (FileResponse) a response object that contains the requested map file
    """

    res = ortho.dtm_dsm_chm(project, task, file, Authorization)
    
    # Write the byte string to a local file as binary data
    with open(file + '.tif', 'wb') as f:
        f.write(res)

    return FileResponse("{}".format(file + '.tif'), filename=file + '.tif')

@app.get("/full/{project}/{task}/{index}")
async def output_creation(project, task, index : IndexName, data: Optional[Data], Authorization: Annotated[str | None, Header()] = None):
    """
    Performs full output creation of orthophoto, DSM, DTM, CHM and an index file from a given project and task.

    :param project: (str) A string representing the name of the project.
    :param task: (str) A string representing the name of the task.
    :param index: (IndexName) An object of type IndexName representing the name of the index file to be created.
    :param data: (Optional[Data]) An optional parameter of type Data which is an object representing the data to be used for creating the index file.
    :param Authorization: (str, optional) An optional parameter of type str which is an annotated header for authorization.
    
    :return: (FileResponse) A FileResponse object representing the final output file with all the above-mentioned files combined.
                            The Final Orthophoto has the following bands (('Blue', 'Green', 'Red', 'NIR', 'Rededge', None, Index, CHM))
    """

    res = ortho.Orthophoto(project, task, 'orthophoto.tif', Authorization)
    with open('orthophoto.tif', 'wb') as f:
        for chunk in res.iter_content(chunk_size=1024):
            if chunk:
                f.write(chunk)
 
    content = ortho.Index_creation(project, task, index, data, Authorization)
    with open("index.tif", 'wb') as f:
        f.write(content)

    dsm = ortho.dtm_dsm_chm(project, task, 'DSM', Authorization)
    with open('dsm.tif', 'wb') as f:
        f.write(dsm)

    dtm = ortho.dtm_dsm_chm(project, task, 'DTM', Authorization)
    with open('dtm.tif', 'wb') as f:
        f.write(dtm)

    resample_list2 = ['index.tif', 'orthophoto.tif']

    #Resize the smaller images
    for image in resample_list2:
        with rasterio.open(image) as src:
            # Calculate the new dimensions based on the desired scale factor
            scale_factor = 0.5  # For example
            new_width = 5662  #int(src.width * scale_factor)
            new_height = 5022 #int(src.height * scale_factor)

            # Resample the source raster to the new dimensions
            data = src.read(
                out_shape=(src.count, new_height, new_width),
                resampling=Resampling.bilinear
            )

            # Update the profile with the new dimensions and other metadata
            profile = src.profile
            profile.update(width=new_width, height=new_height, transform=src.transform)

            # Write the resampled data to a new tiff file
            with rasterio.open(image, 'w', **profile) as dst:
                dst.write(data)
    
    #create the CHM file
    with rasterio.open('dsm.tif') as src1, rasterio.open('dtm.tif') as src2:
        # Check that both rasters have the same shape
        assert src1.shape == src2.shape, "The rasters must have the same shape"
        
        # Read the data from the first bands of both rasters
        band1 = src1.read(1)
        band2 = src2.read(1)
        
        # Subtract the values from the first band of the second raster from the first band of the first raster
        result = band1 - band2
        
        # Update the profile of the output file with the metadata from the first raster
        profile = src1.profile
        
        # Write the result to a new tif file
        with rasterio.open('chm.tif', 'w', **profile) as dst:
            dst.write(result, 1)
    
    
    # Open the source TIFF files
    src1 = rasterio.open('orthophoto.tif')
    src2 = rasterio.open('index.tif')
    src3 = rasterio.open('chm.tif')

    # Define the output file
    dst_file = 'final.tif'

    # Create the output file
    with rasterio.open(
        dst_file,
        'w',
        driver='GTiff',
        height=src1.height,
        width=src1.width,
        count=8,  # The number of bands in the output file
        dtype=src1.dtypes[0],
        crs=src1.crs,
        transform=src1.transform
    ) as dst:
        # Write the first band from the first source file to the output file
        dst.write(src1.read(1), 1)
        dst.write(src1.read(2), 2)
        dst.write(src1.read(3), 3)
        dst.write(src1.read(4), 4)
        dst.write(src1.read(5), 5)
        dst.write(src1.read(6), 6)

        # Write the second band from the second source file to the output file
        dst.write(src2.read(1), 7)

        dst.write(src3.read(1), 8)

    # Close the source and destination files
    src1.close()
    src2.close()
    src3.close()

    return FileResponse("final.tif", filename='final.tif')

@app.post("/inference")
async def inference(file : FileName, Authorization: Annotated[str | None, Header()] = None):
    band_list = seg.load_orthophoto_from_disk(file)
    rgb, ndvi = seg.extract_features(band_list)
    labels = seg.segment_image_with_clustering(ndvi, 5)
    img = seg.prepare_response(labels)

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8888)